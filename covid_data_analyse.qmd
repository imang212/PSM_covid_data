---
title: "Analýza covid dat"
author: "Patrik Poklop, Tomáš Ladislav Kotek"
format: html
editor: visual
---

```{=html}
<style>
#quarto-content {
  display: flex;
  align-content: center;
}
main {
  max-width: 1000px;
  margin-left: auto;
  margin-right: auto;
}
</style>
```

# Analýza covid dat na časové řady

## Načtení dat

```{r}
#| include: false
#Načtení potřebných knihoven
library(tidyverse)
library(lubridate)
library(forecast)
library(tseries)
library(stats)
library(corrplot)
library(gridExtra)
library(TTR)
library(seasonal)
library(vars)

Sys.setlocale("LC_TIME", "C")

#Načtení dat
data <- read.csv("covid_timeseries.csv")

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.width = 20, fig.height = 6)
```

### Kontrola prázdných sloupců

```{r}
#| echo: false
#| message: false
#| warning: false
#Kontrola prázdných sloupců
prazdne_sloupce <- sapply(data, function(x) all(is.na(x)))
prazdne_sloupce
names(data)[prazdne_sloupce]
```

## Úvod

V této analýze se zaměřujem na hledání optimálního modelu pro časovou řadu COVID-19 dat od 5.1.2020 do 8.4.2024. Cílem je otestovat různé přístupy k modelování časových řad a najít ten, který nejlépe popisuje data a poskytuje nejpřesnější predikce.

Analýza postupu je systematicky přes několik kroků: Explorativní analýza - grafické zobrazení a identifikace základních charakteristik Dekompozice - rozdělení řady na trend, sezónní a náhodnou složku Funkční modelování - hledání matematické funkce popisující trend a sezónnost SARIMA modelování - autoregresní přístup zachycující časovou závislost Multivariátní modelování - zahrnutí vlivu ostatních proměnných Srovnání a validace - výběr nejlepšího modelu na základě kritérií

Jako hlavní řadu jsme zvolili new_cases(nové případy COVID-19), protože: Má výrazný dlouhodobý trend (růst během pandemie). Vykazuje sezónní chování (vyšší hodnoty v zimních měsících). Je klíčovou metrikou pro epidemiologické sledování. Má dostupná kvalitní data bez příliš mnoha chybějících hodnot.

## Převod dat na časovou řadu

```{r}
#cat("Struktura načtených dat:\n")
#str(data)

# Převod datumu na správný formát
data$date <- as.Date(data$date)

# Kontrola chybějících hodnot v new_cases
cat("\nChybějící hodnoty v new_cases:\n")
missing_summary <- sapply(data$new_cases, function(x) sum(is.na(x)))
print(missing_summary[missing_summary > 0])

cat("\nChybějící hodnoty v dates:\n")
missing_summary <- sapply(data$date, function(x) sum(is.na(x)))
print(missing_summary[missing_summary > 0])

# Kontrola new_cases sloupce
cat("\nSouhrn new_cases sloupce:\n")
print(summary(data$new_cases))

# Odstranění řádků s chybějícími hodnotami v new_cases
original_rows <- nrow(data)
data <- data[!is.na(data$new_cases), ]
cat("\nOdstraněno", original_rows - nrow(data), "řádků s chybějícími hodnotami v new_cases\n")

# Kontrola kontinuity dat (zda nejsou mezery v datech)
date_range <- range(data$date, na.rm = TRUE)
expected_days <- as.numeric(diff(date_range)) + 1
actual_days <- nrow(data)

if(expected_days != actual_days) {
  cat("V datech jsou mezery, vyplním chybějící data interpolací.\n")
  # Vytvoření kompletní sekvence dat
  full_dates <- seq(from = min(data$date), to = max(data$date), by = "day")
  full_data <- data.frame(date = full_dates)
  # Spojení s originálními daty
  data <- merge(full_data, data, by = "date", all.x = TRUE)
  # Interpolace chybějících hodnot new_cases
  if(any(is.na(data$new_cases))) {
    # Lineární interpolace
    data$new_cases <- approx(x = which(!is.na(data$new_cases)), 
                            y = data$new_cases[!is.na(data$new_cases)], 
                            xout = 1:nrow(data), 
                            rule = 2)$y
    cat("Provedena lineární interpolace chybějících hodnot\n")
  }
}
  
# Vytvoření časové řady
cat("Data začínají od: ",as.numeric(format(min(data$date), "%d")) , as.numeric(format(min(data$date), "%m")), as.numeric(format(min(data$date), "%Y")), "\n")
cat("Data končí: ", as.numeric(format(max(data$date), "%d")), as.numeric(format(max(data$date), "%m")),as.numeric(format(max(data$date), "%Y")))
```

Nejdřív než se data převedli na časovou řadu, zkontrolovalo se, jestli nejsou chybějící hodnoty ve sloupcích, které se budou analyzovat. Zkontrovalo se, jestli nejsou v datech mezery, kolik mají pouorování a jaký je v nich rozsah hodnot.

```{r}
tail(data$date, 1)
start_date <- min(data$date)
start_year <- as.numeric(format(start_date, "%Y"))
start_day <- as.numeric(format(start_date, "%j"))

#ts_data <- ts(data$new_cases, frequency = 365.25)
#ts_data <- ts(data$new_cases, frequency = 30)
ts_data <- ts(data$new_cases, start = c(start_year, start_day), frequency = 365.25)

cat("\nČasová řada vytvořena úspěšně!\n")
cat("Počet pozorování:", length(ts_data), "\n")
cat("Rozsah hodnot:", round(range(ts_data, na.rm = TRUE), 2), "\n")
summary(ts_data)
head(ts_data, 20)
tail(ts_data, 20)
```

Vytvořili jsme časovou řadu v určitém daném rozmezí.

## Grafické zobrazení řady

```{r}
# Grafické zobrazení hlavní řady
p1 <- ggplot(data, aes(x = date, y = new_cases)) +
  geom_line(color = "steelblue", alpha = 0.7) +
  geom_smooth(method = "loess", color = "red", se = FALSE) +
  labs(title = "Vývoj nových případů COVID-19",
       x = "Datum", y = "Počet nových případů",
       subtitle = "Denní data s trendem (červená linie)") +
  theme_minimal()

# Boxplot podle měsíců pro identifikaci sezónnosti
data$month <- factor(month(data$date), labels = month.abb)
p2 <- ggplot(data, aes(x = month, y = new_cases)) +
  geom_boxplot(fill = "lightblue", alpha = 0.7) +
  labs(title = "Sezónní rozdělení nových případů",
       x = "Měsíc", y = "Počet nových případů") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

grid.arrange(p1, p2, ncol = 1)


```

## Dekompozice a identifikace trendu

#### Dekompozice časové řady

Dekompozice umožňuje pochopit strukturu dat, Identifikuje sílu trendové vs. sezónní složky a pomáhá při výběru vhodného typu modelu (aditivní vs. multiplikativní). STL dekompozice je Robustní, flexibilní metoda vhodná pro dlouhé časové řady.

```{r}
# STL dekompozice
stl_decomp <- stl(ts_data, s.window = "periodic", t.window = NULL, robust = TRUE)
plot(stl_decomp, main = "STL dekompozice časové řady nových případů")
```

#### Identifikace trendu pomocí vyhlazení

-   MA(7): Týdenní vyhlazení - odstraní týdenní fluktuace
-   MA(30): Měsíční vyhlazení - zobrazí střednědové trendy
-   MA(365): Roční vyhlazení - zachytí dlouhodobý trend
-   Exponenciální vyhlazení: Dává vyšší váhu novějším pozorováním, vhodné pro predikci

Výsledky říkají, která metoda nejlépe zachycuje základní trend, jak silné jsou krátkodobé vs. dlouhodobé fluktuace, zda je trend stabilní nebo se mění v čase.

```{r}
# Klouzavé průměry různých řádů
ma_7 <- SMA(data$new_cases, n = 7)   
ma_30 <- SMA(data$new_cases, n = 30) 
ma_365 <- SMA(data$new_cases, n = 365) 

# Exponenciální vyrovnání - jednodušší přístup
exp_smooth_model <- HoltWinters(ts_data, gamma = FALSE)

# Vytvoříme jednoduché exponenciální vyhlazení pomocí ETS
ets_model <- ets(ts_data, model = "AAN", damped = FALSE)
exp_smooth_fitted <- fitted(ets_model)

# Zajistíme stejnou délku (ETS vrací stejnou délku jako originální data)
n_obs <- length(data$new_cases)

# Pokud je exp_smooth_fitted kratší, doplníme NA na začátek
if(length(exp_smooth_fitted) < n_obs) {
  exp_smooth_full <- c(rep(NA, n_obs - length(exp_smooth_fitted)), 
                       as.numeric(exp_smooth_fitted))
} else {
  exp_smooth_full <- as.numeric(exp_smooth_fitted[1:n_obs])
}

# Grafické srovnání - pouze metody, které máme
trend_data <- data.frame(
  date = data$date,
  original = data$new_cases,
  ma_7 = ma_7,
  ma_30 = ma_30
)

# Přidáme ma_365 pouze pokud má dostatek dat
if(sum(!is.na(ma_365)) > 100) { trend_data$ma_365 <- ma_365 }

# Přidáme exponenciální vyhlazení
trend_data$exp_smooth <- exp_smooth_full

trend_plot <- trend_data %>%
  pivot_longer(cols = -date, names_to = "method", values_to = "value") %>%
  filter(!is.na(value)) %>%  # Odfiltrujeme NA hodnoty
  ggplot(aes(x = date, y = value, color = method)) +
  geom_line(alpha = 0.7, size = 0.8) +
  scale_color_manual(values = c("original" = "gray50", "ma_7" = "blue", 
                                "ma_30" = "green", "ma_365" = "red",
                                "exp_smooth" = "purple"),
                     name = "Metoda",
                     labels = c("original" = "Originální data", 
                                "ma_7" = "MA(7)", "ma_30" = "MA(30)", 
                                "ma_365" = "MA(365)", "exp_smooth" = "Exp. vyhlazení")) +
  labs(title = "Srovnání metod vyhlazení trendu",
       x = "Datum", y = "Hodnota") +
  theme_minimal() +
  theme(legend.position = "bottom")

print(trend_plot)

# Analýza trendové složky
trend_component <- stl_decomp$time.series[,"trend"]
cat("Souhrn trendové složky:\n")
print(summary(trend_component))

# Analýza sezónní složky
seasonal_component <- stl_decomp$time.series[,"seasonal"]
cat("\nSouhrn sezónní složky:\n")
print(summary(seasonal_component))
```

STL dekompozice identifikovala výrazný rostoucí trend s několika vrcholy odpovídajícími vlnám pandemie. Sezónní složka je relativně stabilní s roční periodicitou. Exponenciální vyrovnání dobře zachycuje dlouhodobý trend.

## Hledání optimálního funkčního modelu (trend + sezónnost)

Testování různých modelů s kombinacemi, jejich srovnání a grafické zobrazení fitování.

```{r}
# Příprava dat pro regresní model
data$t <- 1:nrow(data)
data$sin_365 <- sin(2 * pi * data$t / 365.25)
data$cos_365 <- cos(2 * pi * data$t / 365.25)
data$sin_7 <- sin(2 * pi * data$t / 7)
data$cos_7 <- cos(2 * pi * data$t / 7)

# Model 1: Lineární trend + roční sezónnost
model1 <- lm(new_cases ~ t + sin_365 + cos_365, data = data)
# Model 2: Polynomiální trend + roční sezónnost
model2 <- lm(new_cases ~ poly(t, 2) + sin_365 + cos_365, data = data)
# Model 3: Lineární trend + roční + týdenní sezónnost
model3 <- lm(new_cases ~ t + sin_365 + cos_365 + sin_7 + cos_7, data = data)
# Model 4: Polynomiální trend + roční + týdenní sezónnost
model4 <- lm(new_cases ~ poly(t, 2) + sin_365 + cos_365 + sin_7 + cos_7, data = data)

# Srovnání modelů
models <- list(model1, model2, model3, model4)
model_names <- c("Lin+Roční", "Poly+Roční", "Lin+Roční+Týdenní", "Poly+Roční+Týdenní")

# AIC a BIC srovnání
comparison <- data.frame(
  Model = model_names,
  AIC = sapply(models, AIC),
  BIC = sapply(models, BIC),
  R_squared = sapply(models, function(x) summary(x)$r.squared)
)
print(comparison)

# Nejlepší model podle AIC
best_func_model <- models[[which.min(comparison$AIC)]]
print(summary(best_func_model))

# Grafické zobrazení fitování
data$fitted_func <- fitted(best_func_model)
ggplot(data, aes(x = date)) +
  geom_line(aes(y = new_cases), color = "black", alpha = 0.6, size = 0.5) +
  geom_line(aes(y = fitted_func), color = "red", size = 1) +
  labs(title = "Nejlepší funkční model",
       x = "Datum", y = "Počet případů",
       subtitle = paste("Model:", model_names[which.min(comparison$AIC)])) +
  theme_minimal()
```

Nejlepší funkční model podle AIC je model s polynomiálním trendem a kombinací roční i týdenní sezónnosti. Model vysvětluje značnou část variability dat.

## Hledání optimálního SARIMA modelu

#### Kontrola stacionarity

ADF test: Testuje přítomnost jednotkového kořene KPSS test: Testuje stacionaritu kolem trendu Pokud je řada nestacionární, aplikujeme diferenciaci.

```{r}
# Kontrola stacionarity
adf_test <- adf.test(ts_data)
print(paste("ADF test p-hodnota:", round(adf_test$p.value, 4)))
# KPSS test stacionarity
kpss_test <- kpss.test(ts_data)
print(paste("KPSS test p-hodnota:", round(kpss_test$p.value, 4)))
```

ADF test říká, že řada je stacionární a KPSS, že řada není stacionární. Řada je na hraně stacionarity (obsahuje trend, sezónnost nebo slabou autokorelaci), proto se dělá diferenciace.

#### PACF a ACF grafy

ACF (Autokorelační funkce): Indikuje MA složku PACF (Parciální ACF): Indikuje AR složku

```{r}
# ACF a PACF grafy
par(mfrow = c(2,1))
acf(ts_data, main = "ACF původní řady", lag.max = 100)
pacf(ts_data, main = "PACF původní řady", lag.max = 100)

# Diferenciace pokud je potřeba
if(adf_test$p.value > 0.05) {
  ts_diff <- diff(ts_data)
  adf_diff <- adf.test(ts_diff)
  print(paste("ADF test diferencované řady:", round(adf_diff$p.value, 4)))
  
  par(mfrow = c(2,1))
  acf(ts_diff, main = "ACF diferencované řady", lag.max = 100)
  pacf(ts_diff, main = "PACF diferencované řady", lag.max = 100)
} else {
  ts_diff <- ts_data
}
```

#### Testování SARIMA kombinací

```{r}
cat("Hledání vhodné SARIMA kombinace...\n")
(auto_sarima_a <- auto.arima(ts_data, seasonal = FALSE)) #sezonní diference Zt = 0.004 + 0156*Zt-1 + 0.09*Et-1 + 0.11*Et-2 - 0.53Zt-1
BIC(auto_sarima_a)
#(auto_sarima_b <- auto.arima(ts_data, ic = "bic"))

# Použijeme auto.arima výsledek jako finální
final_sarima <- auto_sarima_a

# Diagnostika residuí
checkresiduals(final_sarima)
```

SARIMA model byl identifikován pomocí automatického vyhledávání. Model zachycuje jak autoregresní chování, tak sezónní komponenty. Diagnostika residuí ukazuje, zda jsou splněny předpoklady modelu.

## Analýza závislosti na jiných řadách

Křížová korelační funkce (CCF): Měří korelaci mezi dvěma časovými řadami při různých zpožděních Pozitivní lag: Y předchází X (Y ovlivňuje budoucí hodnoty X) Negativní lag: X předchází Y (X ovlivňuje budoucí hodnoty Y) Zero lag: Současná korelace

Testované proměnné: new_deaths - úmrtí (očekáváme zpoždění za případy) stringency_index - přísnost opatření (může předcházet změnám v případech) hosp_patients - hospitalizace (může následovat za případy) reproduction_rate - reprodukční číslo (může předcházet změnám)

```{r}
# Příprava dalších časových řad
other_series <- c("new_deaths", "stringency_index", "hosp_patients", "reproduction_rate")

# Křížová korelace s různými zpožděními
ccf_results <- list()
max_lag <- 30

par(mfrow = c(2,2))
for(i in 1:length(other_series)) {
  y_var <- data[[other_series[i]]]
  y_var <- y_var[!is.na(y_var)]
  x_var <- data$new_cases[1:length(y_var)]
  
  ccf_result <- ccf(x_var, y_var, lag.max = max_lag, 
                    main = paste("CCF:", other_series[i]))
  ccf_results[[other_series[i]]] <- ccf_result
}

# Identifikace významných korelací
significant_lags <- list()
for(series in names(ccf_results)) {
  ccf_vals <- ccf_results[[series]]$acf
  lags <- ccf_results[[series]]$lag
  
  # 95% interval spolehlivosti (přibližně)
  n <- length(data$new_cases)
  ci <- 1.96/sqrt(n)
  
  significant_idx <- which(abs(ccf_vals) > ci)
  if(length(significant_idx) > 0) {
    significant_lags[[series]] <- data.frame(
      lag = lags[significant_idx],
      correlation = ccf_vals[significant_idx]
    )
    print(paste("Významné korelace pro", series, ":"))
    print(significant_lags[[series]])
  }
}

```

Identifikovali jsme významné korelace mezi hlavní řadou a ostatními proměnnými s různými zpožděními. Tyto informace použijeme pro konstrukci vícenásobného modelu.

## Optimální model s externími regresory (ARIMAX a VAR model)

Kombinace časové dynamiky ARIMA s vlivem externích faktorů. Arimax model zachycuje autokorelaci v datech a současně modeluje vliv dalších proměnných. VAR model místo jednosměrného vztahu (X → Y) modelujeme vzájemné ovlivnění všech proměnných.

```{r}
# Příprava zpožděných proměnných na základě CCF analýzy
data$deaths_lag <- c(rep(NA, 1), data$new_deaths[1:(nrow(data)-1)])
data$stringency_lag <- c(rep(NA, 5), data$stringency_index[1:(nrow(data)-5)])
data$hosp_lag <- c(rep(NA, 2), data$hosp_patients[1:(nrow(data)-2)])

# Model s externími regresory
external_vars <- cbind(
  deaths_lag = data$deaths_lag,
  stringency_lag = data$stringency_lag,
  hosp_lag = data$hosp_lag
)

# Odstranění NA hodnot
complete_idx <- complete.cases(cbind(data$new_cases, external_vars))
ts_complete <- ts(data$new_cases[complete_idx], frequency = 7)
external_complete <- external_vars[complete_idx, ]

# ARIMAX model
cat("Vyhodnocení ARIMAX modelu: \n")
arimax_model <- auto.arima(ts_complete, xreg = external_complete)
print(summary(arimax_model))

# VAR model pro srovnání
var_data <- data[complete_idx, c("new_cases", "new_deaths", "stringency_index", "hosp_patients")]
var_data <- var_data[complete.cases(var_data), ]

# Optimální lag pro VAR
cat("Vyhodnocení selekce VAR modelu:\n")
var_select <- VARselect(var_data, lag.max = 10, type = "both")
print(var_select$selection)

cat("Vyhodnocení VAR modelu:")
optimal_lag <- var_select$selection["AIC(n)"]
var_model <- VAR(var_data, p = optimal_lag, type = "both")
print(summary(var_model))

# Srovnání modelů
cat("Srovnání všech modelů: \n")
models_comparison <- data.frame(
  Model = c("Funkční", "SARIMA", "ARIMAX", "VAR"),
  AIC = c(AIC(best_func_model), AIC(final_sarima), AIC(arimax_model), AIC(var_model)),
  BIC = c(BIC(best_func_model), BIC(final_sarima), BIC(arimax_model), BIC(var_model))
)
print(models_comparison)
```

ARIMAX model kombinuje autoregresní chování s vlivem externích proměnných. VAR model zachycuje vzájemné závislosti mezi všemi proměnnými. Srovnání AIC/BIC ukazuje, který přístup je nejlepší.

#### Kontrola předpokladů regresních modelů

Zde ověříme, zda naše modely splňují předpoklady, jako je nezávislost reziduí, homoskendasticita (konstantní rozptyl), normalita reziduí a Ljung-Box test.

Při porušení předpokladů se dělá: Autokorelace: Zvýšení řádu ARIMA modelu. Nenormalita: Transformace dat nebo robustní metody. Heteroskedasticita: GARCH modely nebo weighted regression.

```{r}
# Diagnostika residuí pro všechny modely
models_to_check <- list(
  "Funkční" = best_func_model,
  "SARIMA" = final_sarima,
  "ARIMAX" = arimax_model
)

par(mfrow = c(2,2))
for(model_name in names(models_to_check)) {
  model <- models_to_check[[model_name]]
  
  if(inherits(model, "lm")) {
    residuals <- residuals(model)
  } else {
    residuals <- residuals(model)
  }
  
  # ACF residuí
  acf(residuals, main = paste("ACF residuí -", model_name), lag.max = 50)
  # Ljung-Box test
  lb_test <- Box.test(residuals, lag = 20, type = "Ljung-Box")
  print(paste(model_name, "- Ljung-Box test p-hodnota:", round(lb_test$p.value, 4)))
  # Normalita residuí
  shapiro_test <- shapiro.test(sample(residuals, min(5000, length(residuals))))
  print(paste(model_name, "- Shapiro test p-hodnota:", round(shapiro_test$p.value, 4)))
}

# QQ plots pro normalitu
par(mfrow = c(2,2))
for(model_name in names(models_to_check)) {
  model <- models_to_check[[model_name]]
  residuals <- residuals(model)
  qqnorm(residuals, main = paste("Q-Q plot -", model_name))
  qqline(residuals)
}
```

Kontrola ukazuje, zda jsou splněny základní předpoklady modelů - nezávislost residuí (ACF, Ljung-Box test) a jejich normalita (Shapiro test, Q-Q ploty).

## Predikce budoucích hodnot

Zde otestujeme predikční schopnost jednotlivých modelů a porovnáme jejich výkon na 10 období do budoucna.

Srovnáme Funkční model, SARIMA model a ARIMAX model. Vytvoříme Grafické srovnání modelů a kvantitativní hodnocení.

```{r}
# Predikce na 10 období dopředu
horizon <- 10
# Funkční model predikce
future_t <- (nrow(data)+1):(nrow(data)+horizon)
future_data <- data.frame(
  t = future_t,
  sin_365 = sin(2 * pi * future_t / 365.25),
  cos_365 = cos(2 * pi * future_t / 365.25),
  sin_7 = sin(2 * pi * future_t / 7),
  cos_7 = cos(2 * pi * future_t / 7)
)
# Jednoduchá predikce bez složitého rozlišování modelů
pred_func <- tryCatch({
  predict(best_func_model, newdata = future_data, interval = "prediction")
}, error = function(e) {
  cat("Chyba při funkční predikci:", e$message, "\n")
  # Náhradní simple predikce
  last_value <- tail(data$new_cases, 1)
  matrix(rep(last_value, 3*horizon), nrow = horizon, ncol = 3,
         dimnames = list(NULL, c("fit", "lwr", "upr")))
})

cat("Funkční model - predikce dokončena\n")
# SARIMA predikce
pred_sarima <- forecast(final_sarima, h = horizon)
cat("SARIMA predikce dokončena\n")

# ARIMAX predikce (potřebujeme budoucí hodnoty externích proměnných)
# Pro zjednodušení použijeme poslední dostupné hodnoty
last_external <- external_complete[nrow(external_complete), , drop = FALSE]
future_external <- matrix(rep(as.numeric(last_external), horizon), 
                          nrow = horizon, byrow = TRUE)

# Zajistíme správné názvy sloupců
colnames(future_external) <- colnames(external_complete)

cat("Názvy sloupců v trénovacích datech:", colnames(external_complete), "\n")
cat("Názvy sloupců v predikčních datech:", colnames(future_external), "\n")

pred_arimax <- tryCatch({
  forecast(arimax_model, xreg = future_external, h = horizon)
}, error = function(e) {
  cat("Chyba při ARIMAX predikci:", e$message, "\n")
  # Náhradní predikce bez externích regresorů
  forecast(final_sarima, h = horizon)
})
cat("ARIMAX predikce dokončena\n")
```

#### Grafické srovnání a hodnocení modelů

```{r}
tail(data$date, 1)        # poslední datum v datech
max(data$date)            # to samé

cat("\nFunkční model predikce:\n")
print(pred_func)

cat("\nSARIMA predikce (mean, lower, upper):\n")
print(pred_sarima$mean)
print(head(pred_sarima$lower))
print(head(pred_sarima$upper))

cat("\nARIMAX predikce (mean, lower, upper):\n")
print(pred_arimax$mean)
print(head(pred_arimax$lower))
print(head(pred_arimax$upper))
```

```{r}
# Grafické zobrazení predikcí
future_dates <- seq(max(data$date) + 1, by = "day", length.out = horizon)
future_dates             # zda opravdu navazuje (mělo by začínat 2022-01-06)
length(future_dates)      # = horizon


cat("future_dates:", length(future_dates), "\n")
cat("pred_func:", nrow(pred_func), "\n")
cat("sarima:", length(pred_sarima$mean), "\n")
cat("arimax:", length(pred_arimax$mean), "\n")

# Příprava dat pro graf
plot_data <- data.frame(
  date = c(tail(data$date, 50), future_dates),
  actual = c(tail(data$new_cases, 50), rep(NA, horizon)),
  func_pred = c(rep(NA, 50), pred_func[,1]),
  func_lower = c(rep(NA, 50), pred_func[,2]),
  func_upper = c(rep(NA, 50), pred_func[,3]),
  sarima_pred = c(rep(NA, 50), pred_sarima$mean),
  sarima_lower = c(rep(NA, 50), pred_sarima$lower[,2]),
  sarima_upper = c(rep(NA, 50), pred_sarima$upper[,2]),
  arimax_pred = c(rep(NA, 50), pred_arimax$mean),
  arimax_lower = c(rep(NA, 50), pred_arimax$lower[,2]),
  arimax_upper = c(rep(NA, 50), pred_arimax$upper[,2])
)
# Graf predikcí
ggplot(plot_data, aes(x = date)) +
  geom_line(aes(y = actual), color = "black", size = 1, alpha = 0.8, na.rm = TRUE) +
  geom_line(aes(y = func_pred), color = "red", size = 1, na.rm = TRUE) +
  geom_ribbon(aes(ymin = func_lower, ymax = func_upper), fill = "red", alpha = 0.2) +
  geom_line(aes(y = sarima_pred), color = "blue", size = 1,, na.rm = TRUE) +
  geom_ribbon(aes(ymin = sarima_lower, ymax = sarima_upper), fill = "blue", alpha = 0.2) +
  geom_line(aes(y = arimax_pred), color = "green", size = 1,, na.rm = TRUE) +
  geom_ribbon(aes(ymin = arimax_lower, ymax = arimax_upper), fill = "green", alpha = 0.2) +
  geom_vline(xintercept = max(data$date), linetype = "dashed", alpha = 0.5) +
  labs(title = "Predikce nových případů - srovnání modelů",
       x = "Datum", y = "Počet případů",
       subtitle = "Červená: Funkční model, Modrá: SARIMA, Zelená: ARIMAX") +
  theme_minimal() +
  theme(legend.position = "bottom")

# Výpis číselných predikcí
predictions_summary <- data.frame(
  Datum = future_dates,
  Funkční = round(pred_func[,1], 0),
  SARIMA = round(pred_sarima$mean, 0),
  ARIMAX = round(pred_arimax$mean, 0)
)
print("Predikce na příštích 10 dní:")
print(predictions_summary)
```

Srovnání ukazuje rozdíly mezi jednotlivými přístupy. SARIMA model obvykle poskytuje konzervativnější odhady, zatímco funkční model může lépe zachytit sezónní změny. ARIMAX model zohledňuje vlivy externích faktorů.

## Závěrečné srovnání a doporučení

Zhodnocení všech testovaných přístupů a formulace doporučení pro praxi.

```{r}
# Finální srovnání všech modelů
final_comparison <- data.frame(
  Model = c("Funkční (trend+sezónost)", "SARIMA", "ARIMAX"),
  AIC = c(AIC(best_func_model), AIC(final_sarima), AIC(arimax_model)),
  BIC = c(BIC(best_func_model), BIC(final_sarima), BIC(arimax_model)),
  Parametrů = c(length(coef(best_func_model)), 
                length(coef(final_sarima)),
                length(coef(arimax_model))),
  RMSE = c(
    sqrt(mean(residuals(best_func_model)^2)),
    sqrt(mean(residuals(final_sarima)^2)),
    sqrt(mean(residuals(arimax_model)^2))
  )
)

print("Finální srovnání modelů:")
print(final_comparison)

# Doporučení nejlepšího modelu
best_model_idx <- which.min(final_comparison$AIC)
best_model_name <- final_comparison$Model[best_model_idx]

cat("\n=== DOPORUČENÍ ===\n")
cat("Nejlepší model podle AIC:", best_model_name, "\n")
cat("AIC:", round(final_comparison$AIC[best_model_idx], 2), "\n")
cat("RMSE:", round(final_comparison$RMSE[best_model_idx], 2), "\n")
```

#### Závěr
