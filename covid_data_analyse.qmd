---
title: "Analýza covid dat"
author: "Patrik Poklop, Tomáš Ladislav Kotek"
format: html
editor: visual
---

```{=html}
<style>
#quarto-content {
  display: flex;
  align-content: center;
}
main {
  max-width: 1000px;
  margin-left: auto;
  margin-right: auto;
}
</style>
```

# Analýza covid dat na časové řady

## Načtení dat

```{r}
#| include: false
#Načtení potřebných knihoven
library(tidyverse)
library(lubridate)
library(forecast)
library(tseries)
library(stats)
library(corrplot)
library(gridExtra)
library(TTR)
library(seasonal)
library(vars)

Sys.setlocale("LC_TIME", "C")

#Načtení dat
data <- read.csv("covid_timeseries.csv")

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.width = 20, fig.height = 6)
```

```{r}
#| echo: false
#| message: false
#| warning: false
#Kontrola prázdných sloupců
#prazdne_sloupce <- sapply(data, function(x) all(is.na(x)))
#prazdne_sloupce
#names(data)[prazdne_sloupce]
```

## Úvod

V této analýze se zaměřujem na hledání optimálního modelu pro časovou řadu COVID-19 dat od 5.1.2020 do 8.4.2024. Cílem je otestovat různé přístupy k modelování časových řad a najít ten, který nejlépe popisuje data a poskytuje nejpřesnější predikce.

Analýza postupu je systematicky přes několik kroků: Explorativní analýza - grafické zobrazení a identifikace základních charakteristik Dekompozice - rozdělení řady na trend, sezónní a náhodnou složku Funkční modelování - hledání matematické funkce popisující trend a sezónnost SARIMA modelování - autoregresní přístup zachycující časovou závislost Multivariátní modelování - zahrnutí vlivu ostatních proměnných Srovnání a validace - výběr nejlepšího modelu na základě kritérií

Jako hlavní řadu jsme zvolili new_cases(nové případy COVID-19), protože: Má výrazný dlouhodobý trend (růst během pandemie). Vykazuje sezónní chování (vyšší hodnoty v zimních měsících). Je klíčovou metrikou pro epidemiologické sledování. Má dostupná kvalitní data bez příliš mnoha chybějících hodnot.

## Převod dat na časovou řadu

```{r}
#cat("Struktura načtených dat:\n")
#str(data)

# Převod datumu na správný formát
data$date <- as.Date(data$date)

# Kontrola chybějících hodnot v new_cases
cat("\nChybějící hodnoty v new_cases:\n")
missing_summary <- sapply(data$new_cases, function(x) sum(is.na(x)))
print(head(missing_summary[missing_summary > 0]))

cat("\nChybějící hodnoty v dates:\n")
missing_summary <- sapply(data$date, function(x) sum(is.na(x)))
print(head(missing_summary[missing_summary > 0]))

# Kontrola new_cases sloupce
cat("\nSouhrn new_cases sloupce:\n")
print(summary(data$new_cases))

# Odstranění řádků s chybějícími hodnotami v new_cases
original_rows <- nrow(data)
data <- data[!is.na(data$new_cases), ]
cat("\nOdstraněno", original_rows - nrow(data), "řádků s chybějícími hodnotami v new_cases\n")

# Vytvoření měsíc-rok proměnné
data$year_month <- format(data$date, "%Y-%m")
data$year <- as.numeric(format(data$date, "%Y"))
data$month <- as.numeric(format(data$date, "%m"))

# Agregace na měsíční součty
monthly_data <- data %>%
  group_by(year, month, year_month) %>%
  summarise(
    new_cases = sum(new_cases, na.rm = TRUE),
    new_deaths = sum(new_deaths, na.rm = TRUE),
    stringency_index = mean(stringency_index, na.rm = TRUE),
    hosp_patients = mean(hosp_patients, na.rm = TRUE),
    reproduction_rate = mean(reproduction_rate, na.rm = TRUE),
    date = max(date),  # poslední den měsíce jako reprezentant
    .groups = 'drop'
  ) %>%
  arrange(year, month)

cat("Počet měsíčních pozorování:", nrow(monthly_data), "\n")
cat("Rozsah dat:", range(monthly_data$date), "\n")

# Aktualizace hlavní data proměnné
data <- monthly_data

## Kontrola kontinuity dat (zda nejsou mezery v datech)
#date_range <- range(data$date, na.rm = TRUE)
#expected_days <- as.numeric(diff(date_range)) + 1
#actual_days <- nrow(data)
#
#
#if(expected_days != actual_days) {
#  cat("V datech jsou mezery, vyplním chybějící data interpolací.\n")
#  # Vytvoření kompletní sekvence dat
#  full_dates <- seq(from = min(data$date), to = max(data$date), by = #"day")
#  full_data <- data.frame(date = full_dates)
#  # Spojení s originálními daty
#  data <- merge(full_data, data, by = "date", all.x = TRUE)
#  # Interpolace chybějících hodnot new_cases
#  if(any(is.na(data$new_cases))) {
#    # Lineární interpolace
#    data$new_cases <- approx(x = which(!is.na(data$new_cases)), 
#                            y = #data$new_cases[!is.na(data$new_cases)], 
#                            xout = 1:nrow(data), 
#                            rule = 2)$y
#    cat("Provedena lineární interpolace chybějících hodnot\n")
#  }
#}
  
# Vytvoření časové řady
cat("Data začínají od: ",as.numeric(format(min(data$date), "%d")) , as.numeric(format(min(data$date), "%m")), as.numeric(format(min(data$date), "%Y")), "\n")
cat("Data končí: ", as.numeric(format(max(data$date), "%d")), as.numeric(format(max(data$date), "%m")),as.numeric(format(max(data$date), "%Y")))
```

Nejdřív než se data převedli na časovou řadu, zkontrolovalo se, jestli nejsou chybějící hodnoty ve sloupcích, které se budou analyzovat. Zkontrovalo se, jestli nejsou v datech mezery, kolik mají pouorování a jaký je v nich rozsah hodnot.

```{r}
tail(data$date, 1)
start_year <- min(data$year)
start_month <- min(data$month[data$year == start_year])

#ts_data <- ts(data$new_cases, frequency = 365.25)
#ts_data <- ts(data$new_cases, frequency = 30)
ts_data <- ts(data$new_cases, start = c(start_year, start_month), frequency = 12)

cat("\nČasová řada vytvořena úspěšně!\n")
cat("Počet pozorování:", length(ts_data), "\n")
cat("Rozsah hodnot:", round(range(ts_data, na.rm = TRUE), 2), "\n")
summary(ts_data)
head(ts_data, 20)
tail(ts_data, 20)

if(any(is.na(ts_data))) {
    cat("CHYBA: Časová řada stále obsahuje NA hodnoty!\n")
    ts_data <- ts_data[!is.na(ts_data)]
}
```

Vytvořili jsme časovou řadu v určitém daném rozmezí.

## Grafické zobrazení řady

```{r}
# Grafické zobrazení hlavní řady
p1 <- ggplot(data, aes(x = date, y = new_cases)) +
  geom_line(color = "steelblue", alpha = 0.7) +
  geom_smooth(method = "loess", color = "red", se = FALSE) +
  labs(title = "Vývoj nových případů COVID-19",
       x = "Datum", y = "Počet nových případů",
       subtitle = "Měsíční agregace denních dat s trendem (červená linie)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Boxplot podle měsíců pro identifikaci sezónnosti
p2 <- ggplot(data, aes(x = factor(month), y = new_cases)) +
  geom_boxplot(fill = "lightblue", alpha = 0.7) +
  geom_point(alpha = 0.4, position = position_jitter(width = 0.2)) +
  scale_x_discrete(labels = month.abb) +
  labs(title = "Sezónní rozdělení měsíčních případů",
       x = "Měsíc", y = "Počet nových případů") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

grid.arrange(p1, p2, ncol = 1)
```

## Dekompozice a identifikace trendu

#### Dekompozice časové řady

Dekompozice umožňuje pochopit strukturu dat, Identifikuje sílu trendové vs. sezónní složky a pomáhá při výběru vhodného typu modelu (aditivní vs. multiplikativní). STL dekompozice je Robustní, flexibilní metoda vhodná pro dlouhé časové řady.

```{r}
# STL dekompozice
stl_decomp <- stl(ts_data, s.window = "periodic", t.window = NULL, robust = TRUE)
plot(stl_decomp, main = "STL dekompozice časové řady nových případů")
```

#### Identifikace trendu pomocí vyhlazení

-   MA(7): Týdenní vyhlazení - odstraní týdenní fluktuace
-   MA(30): Měsíční vyhlazení - zobrazí střednědové trendy
-   MA(365): Roční vyhlazení - zachytí dlouhodobý trend
-   Exponenciální vyhlazení: Dává vyšší váhu novějším pozorováním, vhodné pro predikci

Výsledky říkají, která metoda nejlépe zachycuje základní trend, jak silné jsou krátkodobé vs. dlouhodobé fluktuace, zda je trend stabilní nebo se mění v čase.

```{r}
# Klouzavé průměry různých řádů
ma_7 <- SMA(data$new_cases, n = 7)   
ma_30 <- SMA(data$new_cases, n = 12) 
ma_365 <- SMA(data$new_cases, n = 30) 

# Exponenciální vyrovnání - jednodušší přístup
exp_smooth_model <- HoltWinters(ts_data, gamma = FALSE)

# Vytvoříme jednoduché exponenciální vyhlazení pomocí ETS
ets_model <- ets(ts_data, model = "AAN", damped = FALSE)
exp_smooth_fitted <- fitted(ets_model)

# Zajistíme stejnou délku (ETS vrací stejnou délku jako originální data)
n_obs <- length(data$new_cases)

# Pokud je exp_smooth_fitted kratší, doplníme NA na začátek
if(length(exp_smooth_fitted) < n_obs) {
  exp_smooth_full <- c(rep(NA, n_obs - length(exp_smooth_fitted)), 
                       as.numeric(exp_smooth_fitted))
} else {
  exp_smooth_full <- as.numeric(exp_smooth_fitted[1:n_obs])
}

# Grafické srovnání - pouze metody, které máme
trend_data <- data.frame(
  date = data$date,
  original = data$new_cases,
  ma_7 = ma_7,
  ma_30 = ma_30
)

# Přidáme ma_365 pouze pokud má dostatek dat
if(sum(!is.na(ma_365)) > 100) { trend_data$ma_365 <- ma_365 }

# Přidáme exponenciální vyhlazení
trend_data$exp_smooth <- exp_smooth_full

trend_plot <- trend_data %>%
  pivot_longer(cols = -date, names_to = "method", values_to = "value") %>%
  filter(!is.na(value)) %>%  # Odfiltrujeme NA hodnoty
  ggplot(aes(x = date, y = value, color = method)) +
  geom_line(alpha = 0.7, size = 0.8) +
  scale_color_manual(values = c("original" = "gray50", "ma_7" = "blue", 
                                "ma_30" = "green", "ma_365" = "red",
                                "exp_smooth" = "purple"),
                     name = "Metoda",
                     labels = c("original" = "Originální data", 
                                "ma_7" = "MA(7)", "ma_30" = "MA(30)", 
                                "ma_365" = "MA(365)", "exp_smooth" = "Exp. vyhlazení")) +
  labs(title = "Srovnání metod vyhlazení trendu",
       x = "Datum", y = "Hodnota") +
  theme_minimal() +
  theme(legend.position = "bottom")

print(trend_plot)

# Analýza trendové složky
trend_component <- stl_decomp$time.series[,"trend"]
cat("Souhrn trendové složky:\n")
print(summary(trend_component))

# Analýza sezónní složky
seasonal_component <- stl_decomp$time.series[,"seasonal"]
cat("\nSouhrn sezónní složky:\n")
print(summary(seasonal_component))
```

STL dekompozice identifikovala výrazný rostoucí trend s několika vrcholy odpovídajícími vlnám pandemie. Sezónní složka je relativně stabilní s roční periodicitou. Exponenciální vyrovnání dobře zachycuje dlouhodobý trend.

## Hledání optimálního funkčního modelu (trend + sezónnost)

Testování různých modelů s kombinacemi, jejich srovnání a grafické zobrazení fitování.

```{r}
# Příprava dat pro regresní model
data$t <- 1:nrow(data)
data$sin_365 <- sin(2 * pi * data$t / 12)
data$cos_365 <- cos(2 * pi * data$t / 12)
data$sin_7 <- sin(2 * pi * data$t / 7)
data$cos_7 <- cos(2 * pi * data$t / 7)

# Model 1: Lineární trend + roční sezónnost
model1 <- lm(new_cases ~ t + sin_365 + cos_365, data = data)
# Model 2: Polynomiální trend + roční sezónnost
model2 <- lm(new_cases ~ poly(t, 2) + sin_365 + cos_365, data = data)
# Model 3: Lineární trend + roční + týdenní sezónnost
model3 <- lm(new_cases ~ t + sin_365 + cos_365 + sin_7 + cos_7, data = data)
# Model 4: Polynomiální trend + roční + týdenní sezónnost
model4 <- lm(new_cases ~ poly(t, 2) + sin_365 + cos_365 + sin_7 + cos_7, data = data)

# Srovnání modelů
models <- list(model1, model2, model3, model4)
model_names <- c("Lin+Roční", "Poly+Roční", "Lin+Roční+Týdenní", "Poly+Roční+Týdenní")

# AIC a BIC srovnání
comparison <- data.frame(
  Model = model_names,
  AIC = sapply(models, AIC),
  BIC = sapply(models, BIC),
  R_squared = sapply(models, function(x) summary(x)$r.squared)
)
print(comparison)

# Nejlepší model podle AIC
best_func_model <- models[[which.min(comparison$AIC)]]
print(summary(best_func_model))

# Grafické zobrazení fitování
data$fitted_func <- fitted(best_func_model)
ggplot(data, aes(x = date)) +
  geom_line(aes(y = new_cases), color = "black", alpha = 0.6, size = 0.5) +
  geom_line(aes(y = fitted_func), color = "red", size = 1) +
  labs(title = "Nejlepší funkční model",
       x = "Datum", y = "Počet případů",
       subtitle = paste("Model:", model_names[which.min(comparison$AIC)])) +
  theme_minimal()
```

Nejlepší funkční model podle AIC je model s polynomiálním trendem a kombinací roční i týdenní sezónnosti. Model vysvětluje značnou část variability dat.

## Hledání optimálního SARIMA modelu

#### Kontrola stacionarity

ADF test: Testuje přítomnost jednotkového kořene KPSS test: Testuje stacionaritu kolem trendu Pokud je řada nestacionární, aplikujeme diferenciaci.

```{r}
# Kontrola stacionarity
adf_test <- adf.test(ts_data)
print(paste("ADF test p-hodnota:", round(adf_test$p.value, 4)))
# KPSS test stacionarity
kpss_test <- kpss.test(ts_data)
print(paste("KPSS test p-hodnota:", round(kpss_test$p.value, 4)))
```

ADF test říká, že řada je stacionární a KPSS, že řada není stacionární. Řada je na hraně stacionarity (obsahuje trend, sezónnost nebo slabou autokorelaci), proto se dělá diferenciace.

#### PACF a ACF grafy

ACF (Autokorelační funkce): Indikuje MA složku PACF (Parciální ACF): Indikuje AR složku

```{r}
# ACF a PACF grafy
par(mfrow = c(2,1))
acf(ts_data, main = "ACF původní řady", lag.max = 100)
pacf(ts_data, main = "PACF původní řady", lag.max = 100)

# Diferenciace pokud je potřeba
if(adf_test$p.value > 0.05) {
  ts_diff <- diff(ts_data)
  adf_diff <- adf.test(ts_diff)
  print(paste("ADF test diferencované řady:", round(adf_diff$p.value, 4)))
  
  par(mfrow = c(2,1))
  acf(ts_diff, main = "ACF diferencované řady", lag.max = 100)
  pacf(ts_diff, main = "PACF diferencované řady", lag.max = 100)
} else {
  ts_diff <- ts_data
}
```

#### Testování SARIMA kombinací

```{r}
cat("Hledání vhodné SARIMA kombinace...\n")
(auto_sarima_a <- auto.arima(ts_data, seasonal = TRUE)) #sezonní diference Zt = 0.004 + 0156*Zt-1 + 0.09*Et-1 + 0.11*Et-2 - 0.53Zt-1
BIC(auto_sarima_a)
#(auto_sarima_b <- auto.arima(ts_data, ic = "bic"))

selected_sarima <- tryCatch({
  arima(ts_data, 
        order = c(1, 1, 1),
        seasonal = list(order = c(1, 1, 1), period = 12))  # period = 12 pro měsíce
}, error = function(e) {
  cat("Hlavní SARIMA model selhal:", e$message, "\n")
  # Jednodušší fallback
  arima(ts_data, order = c(0, 1, 1))
})
alternative_sarima <- tryCatch({
  arima(ts_data, 
        order = c(0, 1, 1),
        seasonal = list(order = c(1, 1, 0), period = 12))
}, error = function(e) {
  cat("Alternativní model selhal:", e$message, "\n")
  return(NULL)
})

if(!is.null(alternative_sarima)) {
  aic1 <- AIC(selected_sarima)
  aic2 <- AIC(alternative_sarima)
  
  cat("SARIMA(1,1,1)x(1,1,1)[12] AIC:", round(aic1, 2), "\n")
  cat("SARIMA(0,1,1)x(1,1,0)[12] AIC:", round(aic2, 2), "\n")
  
  if(aic2 < aic1) {
    final_sarima <- alternative_sarima
    cat("Lepší je alternativní model.\n")
  } else {
    final_sarima <- selected_sarima
    cat("Lepší je původní model.\n")
  }
} else {
  final_sarima <- selected_sarima
  cat("Používám původní SARIMA model pro měsíční data.\n")
}

# Diagnostika residuí
checkresiduals(final_sarima)
```

SARIMA model byl identifikován pomocí automatického vyhledávání. Model zachycuje jak autoregresní chování, tak sezónní komponenty. Diagnostika residuí ukazuje, zda jsou splněny předpoklady modelu.

## Analýza závislosti na jiných řadách

Křížová korelační funkce (CCF): Měří korelaci mezi dvěma časovými řadami při různých zpožděních Pozitivní lag: Y předchází X (Y ovlivňuje budoucí hodnoty X) Negativní lag: X předchází Y (X ovlivňuje budoucí hodnoty Y) Zero lag: Současná korelace

Testované proměnné: new_deaths - úmrtí (očekáváme zpoždění za případy) stringency_index - přísnost opatření (může předcházet změnám v případech) hosp_patients - hospitalizace (může následovat za případy) reproduction_rate - reprodukční číslo (může předcházet změnám)

```{r}
# Příprava dalších časových řad
other_series <- c("new_deaths", "stringency_index", "hosp_patients", "reproduction_rate")

# Křížová korelace s různými zpožděními
ccf_results <- list()
max_lag <- 12

par(mfrow = c(2,2))
for(i in 1:length(other_series)) {
  y_var <- data[[other_series[i]]]
  y_var <- y_var[!is.na(y_var)]
  x_var <- data$new_cases[1:length(y_var)]
  
  ccf_result <- ccf(x_var, y_var, lag.max = max_lag, 
                    main = paste("CCF:", other_series[i]))
  ccf_results[[other_series[i]]] <- ccf_result
}

# Identifikace významných korelací
significant_lags <- list()
for(series in names(ccf_results)) {
  ccf_vals <- ccf_results[[series]]$acf
  lags <- ccf_results[[series]]$lag
  
  # 95% interval spolehlivosti (přibližně)
  n <- length(data$new_cases)
  ci <- 1.96/sqrt(n)
  
  significant_idx <- which(abs(ccf_vals) > ci)
  if(length(significant_idx) > 0) {
    significant_lags[[series]] <- data.frame(
      lag = lags[significant_idx],
      correlation = ccf_vals[significant_idx]
    )
    print(paste("Významné korelace pro", series, ":"))
    print(head(significant_lags[[series]]))
  }
}

```

Identifikovali jsme významné korelace mezi hlavní řadou a ostatními proměnnými s různými zpožděními. Tyto informace použijeme pro konstrukci vícenásobného modelu.

## Optimální model s externími regresory (ARIMAX a VAR model)

Kombinace časové dynamiky ARIMA s vlivem externích faktorů. Arimax model zachycuje autokorelaci v datech a současně modeluje vliv dalších proměnných. VAR model místo jednosměrného vztahu (X → Y) modelujeme vzájemné ovlivnění všech proměnných.

```{r}
# Příprava zpožděných proměnných na základě CCF analýzy
data$deaths_lag <- c(rep(NA, 1), data$new_deaths[1:(nrow(data)-1)])
data$stringency_lag <- c(rep(NA, 5), data$stringency_index[1:(nrow(data)-5)])
data$hosp_lag <- c(rep(NA, 2), data$hosp_patients[1:(nrow(data)-2)])

# Model s externími regresory
external_vars <- cbind(
  deaths_lag = data$deaths_lag,
  stringency_lag = data$stringency_lag,
  hosp_lag = data$hosp_lag
)

# Odstranění NA hodnot
complete_idx <- complete.cases(cbind(data$new_cases, external_vars))
ts_complete <- ts(data$new_cases[complete_idx], start = c(start_year, start_month), frequency = 365.25)
external_complete <- external_vars[complete_idx, ]

# ARIMAX model
arimax_model <- auto.arima(ts_complete, xreg = external_complete)
print(summary(arimax_model))
length(fitted(arimax_model))

# Srovnání modelů
cat("Srovnání všech modelů: \n")
models_comparison <- data.frame(
  Model = c("Funkční", "SARIMA", "ARIMAX"),
  AIC = c(AIC(best_func_model), AIC(final_sarima), AIC(arimax_model)),
  BIC = c(BIC(best_func_model), BIC(final_sarima), BIC(arimax_model))
)

print(models_comparison)
```

ARIMAX model kombinuje autoregresní chování s vlivem externích proměnných. VAR model zachycuje vzájemné závislosti mezi všemi proměnnými. Srovnání AIC/BIC ukazuje, který přístup je nejlepší.

#### Kontrola předpokladů regresních modelů

Zde ověříme, zda naše modely splňují předpoklady, jako je nezávislost reziduí, homoskendasticita (konstantní rozptyl), normalita reziduí a Ljung-Box test.

Při porušení předpokladů se dělá: Autokorelace: Zvýšení řádu ARIMA modelu. Nenormalita: Transformace dat nebo robustní metody. Heteroskedasticita: GARCH modely nebo weighted regression.

```{r}
# Diagnostika residuí pro všechny modely
models_to_check <- list(
  "Funkční" = best_func_model,
  "SARIMA" = final_sarima,
  "ARIMAX" = arimax_model
)

par(mfrow = c(2,2))
for(model_name in names(models_to_check)) {
  model <- models_to_check[[model_name]]
  
  if(inherits(model, "lm")) {
    residuals <- residuals(model)
  } else {
    residuals <- residuals(model)
  }
  
  # ACF residuí
  acf(residuals, main = paste("ACF residuí -", model_name), lag.max = 50)
  # Ljung-Box test
  lb_test <- Box.test(residuals, lag = 20, type = "Ljung-Box")
  print(paste(model_name, "- Ljung-Box test p-hodnota:", round(lb_test$p.value, 4)))
  # Normalita residuí
  
shapiro_test <- shapiro.test(sample(residuals, min(5000, length(residuals))))

  print(paste(model_name, "- Shapiro test p-hodnota:", round(shapiro_test$p.value, 4)))
}

# QQ plots pro normalitu
par(mfrow = c(2,2))
for(model_name in names(models_to_check)) {
  model <- models_to_check[[model_name]]
  residuals <- residuals(model)
  qqnorm(residuals, main = paste("Q-Q plot -", model_name))
  qqline(residuals)
}
```

Kontrola ukazuje, zda jsou splněny základní předpoklady modelů - nezávislost residuí (ACF, Ljung-Box test) a jejich normalita (Shapiro test, Q-Q ploty).

## Predikce budoucích hodnot

Zde otestujeme predikční schopnost jednotlivých modelů a porovnáme jejich výkon na 10 období do budoucna.

Srovnáme Funkční model, SARIMA model a ARIMAX model. Vytvoříme Grafické srovnání modelů a kvantitativní hodnocení.

```{r}
# Predikce na 10 období dopředu
horizon <- 10
# Kontrola kvality modelů před predikcí
cat("Kontrola SARIMA modelu:\n")
cat("Koeficienty:", coef(final_sarima), "\n")
cat("Sigma2:", final_sarima$sigma2, "\n")
cat("Loglik:", final_sarima$loglik, "\n")
# Kontrola časové řady
cat("\nKontrola časové řady pro predikci:\n")
cat("Délka:", length(ts_data), "\n")
cat("Start:", paste(start(ts_data), collapse = ", "), "\n")
cat("Frequency:", frequency(ts_data), "\n")
cat("Posledních 5 hodnot:", tail(ts_data, 5), "\n")

# Funkční model predikce
future_t <- (nrow(data)+1):(nrow(data)+horizon)
future_data <- data.frame(
  t = future_t,
  sin_365 = sin(2 * pi * future_t / 365.25),
  cos_365 = cos(2 * pi * future_t / 365.25),
  sin_7 = sin(2 * pi * future_t / 7),
  cos_7 = cos(2 * pi * future_t / 7)
)
# Jednoduchá predikce bez složitého rozlišování modelů
pred_func <- predict(best_func_model, newdata = future_data, interval = "prediction")
cat("Funkční model - predikce dokončena\n")
# SARIMA predikce
if(is.null(final_sarima) || any(is.na(coef(final_sarima)))) {
  cat("SARIMA model je nevalidní! Vytvářím nový jednoduchý model...\n")
  simple_ts <- ts(data$new_cases[!is.na(data$new_cases)], frequency = 1)
  final_sarima <- tryCatch({
    arima(simple_ts, order = c(1, 1, 1))
  }, error = function(e) {
    cat("I jednoduchý ARIMA selhal:", e$message, "\n")
    arima(simple_ts, order = c(0, 1, 0))  # random walk
  })
}

pred_sarima <- forecast(final_sarima, h = horizon)
cat("SARIMA predikce dokončena\n")

# ARIMAX predikce (potřebujeme budoucí hodnoty externích proměnných)
# Pro zjednodušení použijeme poslední dostupné hodnoty
last_external <- external_complete[nrow(external_complete), , drop = FALSE]
future_external <- matrix(rep(as.numeric(last_external), horizon), 
                          nrow = horizon, byrow = TRUE)

colnames(future_external) <- colnames(external_complete)


cat("Názvy sloupců v trénovacích datech:", colnames(external_complete), "\n")
cat("Názvy sloupců v predikčních datech:", colnames(future_external), "\n")
pred_arimax = forecast(arimax_model, xreg = future_external, h = horizon)
cat("ARIMAX predikce dokončena\n")
```

#### Grafické srovnání a hodnocení modelů

```{r}
tail(data$date, 1)        # poslední datum v datech
```

```{r}
# Grafické zobrazení predikcí
future_dates <- seq(max(data$date) + 1, by = "day", length.out = horizon)

cat("Budoucí data:", as.character(future_dates[1:3]), "...\n")

# === KONTROLA PŘED GRAFEM ===
cat("\n=== FINÁLNÍ KONTROLA ===\n")
cat("Funkční - rozsah:", range(pred_func[,1]), "\n") 
cat("SARIMA - rozsah:", range(pred_sarima$mean), "\n")
cat("ARIMAX - rozsah:", range(pred_arimax$mean), "\n")

# Test na nuly
if(all(pred_sarima$mean == 0)) {
  cat("PROBLÉM: SARIMA predikuje samé nuly!\n")
  cat("Poslední hodnota v časové řadě:", tail(as.numeric(ts_data), 1), "\n")
  cat("Model summary:\n")
  print(summary(final_sarima))
  # Oprava: použij poslední hodnotu
  pred_sarima$mean <- rep(tail(as.numeric(ts_data), 1), horizon)
  pred_sarima$lower[,2] <- pred_sarima$mean * 0.8
  pred_sarima$upper[,2] <- pred_sarima$mean * 1.2
}


# Určíme počet historických pozorování k zobrazení (posledních 24 měsíců nebo méně)
last_n_obs <- 12  
cat("Zobrazím posledních", last_n_obs, "měsíčních pozorování\n")
if(nrow(data) < last_n_obs) last_n_obs <- nrow(data);


# Historická data
historical_dates <- tail(data$date, last_n_obs)
historical_values <- tail(data$new_cases, last_n_obs)

# Kontrola, že predikce mají správnou délku a nejsou NA
pred_func_clean <- pred_func[,1]
pred_func_lower <- pred_func[,2] 
pred_func_upper <- pred_func[,3]

pred_sarima_clean <- as.numeric(pred_sarima$mean)
pred_sarima_lower <- as.numeric(pred_sarima$lower[,2])
pred_sarima_upper <- as.numeric(pred_sarima$upper[,2])

pred_arimax_clean <- as.numeric(pred_arimax$mean)
pred_arimax_lower <- as.numeric(pred_arimax$lower[,2])
pred_arimax_upper <- as.numeric(pred_arimax$upper[,2])

# Náhrada NA hodnotami z SARIMA predikce pokud je potřeba
if(any(is.na(pred_func_clean))) {
  cat("Opravuji NA v funkčních predikcích\n")
  pred_func_clean[is.na(pred_func_clean)] <- pred_sarima$mean[is.na(pred_func_clean)]
  pred_func_lower[is.na(pred_func_lower)] <- pred_sarima$lower[is.na(pred_func_lower),2]
  pred_func_upper[is.na(pred_func_upper)] <- pred_sarima$upper[is.na(pred_func_upper),2]
}

# Vytvoření clean dat pro ggplot
plot_data_clean <- data.frame(
  date = c(historical_dates, future_dates),
  actual = c(historical_values, rep(NA, horizon)),
  
  # Funkční model
  func_pred = c(rep(NA, last_n_obs), pred_func_clean),
  func_lower = c(rep(NA, last_n_obs), pred_func_lower),
  func_upper = c(rep(NA, last_n_obs), pred_func_upper),
  
  # SARIMA model  
  sarima_pred = c(rep(NA, last_n_obs), as.numeric(pred_sarima$mean)),
  sarima_lower = c(rep(NA, last_n_obs), as.numeric(pred_sarima$lower[,2])),
  sarima_upper = c(rep(NA, last_n_obs), as.numeric(pred_sarima$upper[,2])),
  
  # ARIMAX model
  arimax_pred = c(rep(NA, last_n_obs), as.numeric(pred_arimax$mean)),
  arimax_lower = c(rep(NA, last_n_obs), as.numeric(pred_arimax$lower[,2])),
  arimax_upper = c(rep(NA, last_n_obs), as.numeric(pred_arimax$upper[,2]))
)

# Kontrola finálních dat
cat("Kontrola plot_data_clean:\n")
cat("Počet řádků:", nrow(plot_data_clean), "\n")
cat("NA v actual:", sum(is.na(plot_data_clean$actual)), "\n")
cat("NA v func_pred:", sum(is.na(plot_data_clean$func_pred)), "\n")
cat("NA v sarima_pred:", sum(is.na(plot_data_clean$sarima_pred)), "\n")

```

```{r}
# Vylepšený graf predikcí
prediction_plot <- ggplot(plot_data_clean, aes(x = date)) +
  # Historická data - body a čáry
  geom_line(aes(y = actual), color = "black", size = 1.2, alpha = 0.8, na.rm = TRUE) +
  geom_point(aes(y = actual), color = "black", size = 2, alpha = 0.7, na.rm = TRUE) +
  # Funkční model
  geom_line(aes(y = func_pred), color = "red", size = 1.2, na.rm = TRUE) +
  geom_point(aes(y = func_pred), color = "red", size = 2, na.rm = TRUE) +
  geom_ribbon(aes(ymin = func_lower, ymax = func_upper), fill = "red", alpha = 0.2, na.rm = TRUE) +
  # SARIMA model
  geom_line(aes(y = sarima_pred), color = "blue", size = 1.2, na.rm = TRUE) +
  geom_point(aes(y = sarima_pred), color = "blue", size = 2, na.rm = TRUE) +
  geom_ribbon(aes(ymin = sarima_lower, ymax = sarima_upper), fill = "blue", alpha = 0.2, na.rm = TRUE) +
  # ARIMAX model
  geom_line(aes(y = arimax_pred), color = "green", size = 1.2, na.rm = TRUE) +
  geom_point(aes(y = arimax_pred), color = "green", size = 2, na.rm = TRUE) +
  geom_ribbon(aes(ymin = arimax_lower, ymax = arimax_upper), fill = "green", alpha = 0.2, na.rm = TRUE) +
  # Vertikální čára oddělující historii od predikcí
  geom_vline(xintercept = max(historical_dates), linetype = "dashed", alpha = 0.7, color = "gray50", size = 1) +
  # Lepší popisky a téma
  labs(title = "Predikce měsíčních nových případů - srovnání modelů", x = "Datum", y = "Počet případů (měsíčně)",
       subtitle = paste("Historická data (černá) | Predikce: Funkční (červená), SARIMA (modrá), ARIMAX (zelená)", "\nPřerušovaná čára označuje konec historických dat")) +
  theme_minimal() +
  theme(legend.position = "none", plot.title = element_text(size = 14, hjust = 0.5, face = "bold"), plot.subtitle = element_text(size = 11, hjust = 0.5),
    axis.text.x = element_text(angle = 45, hjust = 1), panel.grid.minor = element_blank())
#  # Rozumné limity osy y
#  + coord_cartesian(ylim = c(0, max(c(historical_values, #pred_func_clean, pred_sarima, pred_arimax_clean), na.rm = TRUE) * #1.1))

print(prediction_plot)

# Číselný souhrn predikcí
cat("\n=== ČÍSELNÉ PREDIKCE (měsíční hodnoty) ===\n")
predictions_summary <- data.frame(Měsíc = future_dates, Funkční = round(pred_func_clean, 0), SARIMA = round(pred_sarima_clean, 0), ARIMAX = round(pred_arimax_clean, 0))

print("Predikce na příštích 10 měsíců:")
print(predictions_summary)
```

Srovnání ukazuje rozdíly mezi jednotlivými přístupy. SARIMA model obvykle poskytuje konzervativnější odhady, zatímco funkční model může lépe zachytit sezónní změny. ARIMAX model zohledňuje vlivy externích faktorů.

## Závěrečné srovnání a doporučení

Zhodnocení všech testovaných přístupů a formulace doporučení pro praxi.

```{r}
# Finální srovnání všech modelů
final_comparison <- data.frame(
  Model = c("Funkční (trend+sezónost)", "SARIMA", "ARIMAX"),
  AIC = c(AIC(best_func_model), AIC(final_sarima), AIC(arimax_model)),
  BIC = c(BIC(best_func_model), BIC(final_sarima), BIC(arimax_model)),
  Parametrů = c(length(coef(best_func_model)), 
                length(coef(final_sarima)),
                length(coef(arimax_model))),
  RMSE = c(
    sqrt(mean(residuals(best_func_model)^2)),
    sqrt(mean(residuals(final_sarima)^2)),
    sqrt(mean(residuals(arimax_model)^2))
  )
)

print("Finální srovnání modelů:")
print(final_comparison)

# Doporučení nejlepšího modelu
best_model_idx <- which.min(final_comparison$AIC)
best_model_name <- final_comparison$Model[best_model_idx]

cat("\n=== DOPORUČENÍ ===\n")
cat("Nejlepší model podle AIC:", best_model_name, "\n")
cat("AIC:", round(final_comparison$AIC[best_model_idx], 2), "\n")
cat("RMSE:", round(final_comparison$RMSE[best_model_idx], 2), "\n")
```
